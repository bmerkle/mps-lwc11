#summary Implementation of Step 2, 0.2

= Task =

0.2 Code generation to GPL such as Java, C#, C++ or XML

Generate Java Beans (or some equivalent data structure in C#, Scala, etc.) with setters, getters and fields for the properties.

= Details =

This step is intended to demonstrate code generation. In MPS, however, there is no real code generation per se. Everything is a model-to-model transformation (there is even a meta model for text (lines, words, lists)). 

Specifically, since MPS comes with an implementation of Java (called Base Language), generating Java Beans, as requested by this task, is actually the creation of a "Java model". 

Let us look at the implementation to make this clearer.

== Defining a Generator ==

The first step we have to perform is to create a generator (note that although these things are actually model transformations, the "container" that contains them is called a generator). Use the context menu on the entities language to run New->Generator to create one. The generator's name doesn't really matter, I usually call it main. The result should look something like this.

https://mps-lwc11.googlecode.com/svn/trunk/lwc11/wiki-images/lwc11step2At02-newGenerator.png

The important content of the generator at this point is the so-called mapping configuration. This is a configuration that determines which language concepts are transformed how. These mapping configurations have different kinds of rules. We will need two of these:

  * root mapping rules are used to map concepts into a root concept (those with "can be root" set to true). In the generator we're currently building, we'll use one of these to map entities to Java classes.
  * reduction rules are used to replace a concept with another concept. The original concept is replaced (at the same location!) with the result of the transformation rule. We will use this here for the types of attributes.

== Mapping the Entity to a Java Class ==

As the heading suggests, we want to create a Java class. Since we don't simply generate text, but rather "instantiate" a _Class_ concept from the Java implementation in MPS, we first have to make sure Java is actually available in our language project. Right-click on the entities language and select Language Properties. Go to the Dependencies tab and press the little plus symbol in the Used Languages section. Select jetbrains.mps.baseLanguage.

Let's now create a root mapping rule (by pressing enter in the respective slot). For the concept, choose _Entity_. You now have to specify the template that performs the transformation. In the respective slot, press alt-enter and select "New Root Template". From the popup menu that shows up then, select _class_. The result should look like this:

https://mps-lwc11.googlecode.com/svn/trunk/lwc11/wiki-images/lwc11step2At02-mappingRule.png

You can now ctrl-click onto the template name in the mapping configuration to open the newly created template. It should look someth√≠ng like this:

https://mps-lwc11.googlecode.com/svn/trunk/lwc11/wiki-images/lwc11step2At02-template0.png

Notice how it resembles a valid, complete Java class! This is because MPS uses the same projectional approach in templates it uses for any other piece of code. Because you've selected a _class_ as the thing to be generated, a complete, yet "empty" class is shown in the template.

We now have to make the template sensible. The first thing we want to do is change the name of the generated class. It should be the name of the entity from which the class is generated, maybe with some kind of suffix or something. 

Tempaltes in MPS work the following way: you first write valid example code. Then you annotate this code with "replacement rules", called macros. In our case, we have already writte valid example code: the class. We now have to replace the name with something that is derived from the input node (the Entity). We use a property macro for that (because we want to change the value of a propery, the class name). Put the cursor onto the class name (map_Entity) and press alt-enter. Then select "Add Property Macro". In the inspector (open it with Alt-2 if it is not visible) you can now see an empty function body. This function is used to calculate the value that should be used as the new value for the property we're replacing. In our case we put the following code, to calculate the class name (note how the _node_ variable referneces the current context, in this case, the input node of type _Entity_).

https://mps-lwc11.googlecode.com/svn/trunk/lwc11/wiki-images/lwc11step2At02-template1-propertyMacro.png

At this point we have functioning, albeit incomplete, template.



