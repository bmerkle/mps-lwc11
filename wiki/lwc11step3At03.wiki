#summary Implementation of Step 3, 0.3

= Task =

0.3 Simple constraint checks such as name-uniqueness 

For example, check the name uniqueness of the properties in the entities.

= Details =

MPS has different kinds of constraints which we'll describe briefly here. For the 0.3 task we will only need one of them.


== Concept-specific Constraints ==

Note that all of these constraints are not "just" constraints in the sense that they check an existing model. Rather, they prevent a potentially wrong model from being built; this means, they affect code completion as well.

Reference constraints define which nodes are valid targets for a reference (a pointer). The constraint returns the set of valid target nodes. These kinds of constraints are otherwise known as scopes and are demonstrated in a later step of this tutorial.

Property Constraints are invoked when working with properties. Remember, properties, unlike child relationships, are primitives (typed int, string or boolean). As part of the property constraint you can define a setter, a getter and a validation check. 

Let us implement a simple check that makes sure that properties start with a capital letter. Open the Entity concept and select the constraints tab. It is probably empty, so you should click into the white area to create a new one. You can then create a new property constraint by pressing enter in the respective slot. This is how the result will look:

https://mps-lwc11.googlecode.com/svn/trunk/lwc11/wiki-images/lwc11step3At03-propertyConstraint.png

You can now choose the name property in the respective field and press enter in the "is valid" slot. Here you can now enter a boolean that determines whether the value is valid. Here is a possible implementation:

https://mps-lwc11.googlecode.com/svn/trunk/lwc11/wiki-images/lwc11step3At03-propertyConstraintImpl.png

If you regenerate the language and go back to the example model, you cannot even enter a name with a lower case first character, it doesn't bind and the entered value stays red. The disadvantage is that you cannot define an error message here for your validation rule. So you might want to use the non typesystem rule approach to constraints defined below alternatively.

There are also constraints that can be used to validate the tree structure beyond what the structure definition can do. They are called "can be child", "can be parent", and "can be ancestor". Note that these constraints also influence the code completion menu! So they prevent "wrong trees from being built". 
  
  * can be child: you get passed in the parent node of the current node (which is an instance of the concept for which you currently define the constraints), and you determine whether your current concept can potentially live below the passed in parent. For example, if you'd add a can be child constraint to Entity with the body of !(parentNode.isInstanceOf(EntityResource)); then this would prevent Entities from being added under an EntityResource. Note how this constraint is being written from the perspective of the child, i.e. you modify the child concept (by adding the constraint). For the next two, this is the other way round.
  * can be parent: you get the concept passed in you could instantiate (it's not yet a node because the constraint is evaluated before the tree is constructed!) and you determine whether this kind of child would be valid. For example, if I added the code !(childConcept == concept/Entity/); as the can be parent constraint for EntityResource, it would not be valid to add Entities below an EntityResource. Note how this constraint is written from the perspective of the parent, i.e. you modify the parent concept.
  * can be ancestor is like can be child, but it works recursively down the tree, i.e. the children don't have to be direct children. For example, if I wrote !(childConcept == concept/EntityType/); in the can be ancestor constraint for EntityResource, I could not add any EntityTypes as descendents at any nesting level below EntityResource. Note that this one is potentially much slower than the can be child, so use the latter whenever possible.
    
== Cross-Concept Constraints ==